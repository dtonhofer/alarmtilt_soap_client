package eu.qleap.soapyatc;

import java.io.File;

import static name.heavycarbon.checks.BasicChecks.*

import javax.xml.namespace.QName

import name.heavycarbon.carpetbag.ResourceHelpGroovy

import org.slf4j.Logger
import org.slf4j.LoggerFactory

import v3.res.soap.webservice.alarmtilt.com.AlarmTILTRestrictedWebService
import v3.res.soap.webservice.alarmtilt.com.AuthParam
import v3.res.soap.webservice.alarmtilt.com.AuthType
import v3.res.soap.webservice.alarmtilt.com.LaunchProcedureParam
import v3.res.soap.webservice.alarmtilt.com.LaunchProcedureResult
import v3.res.soap.webservice.alarmtilt.com.LaunchProcedureResultEnum;
import v3.res.soap.webservice.alarmtilt.com.PingServiceResult
import v3.res.soap.webservice.alarmtilt.com.PingServiceResultEnum;
import v3.res.soap.webservice.alarmtilt.com.WsResV3
import eu.qleap.soapyatc.argproc.ArgsProcessor
import eu.qleap.soapyatc.config.ConfigInfo
import eu.qleap.soapyatc.elements.AtpMap
import eu.qleap.soapyatc.elements.AtwsMap
import eu.qleap.soapyatc.elements.AtwsName

/* 34567890123456789012345678901234567890123456789012345678901234567890123456789
 *******************************************************************************
 * Main class to invoke to do a SOAP call to the AlarmTILT server
 * 
 * This has been built from a class generated by Apache CXF
 *
 * Arguments of interest for the runtime:
 * 
 * -Dnetworkaddress.cache.ttl=0 
 * -Dcom.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true 
 * -Dcom.sun.xml.internal.ws.transport.http.HttpAdapter.dump=true
 *
 * It turns out that having the "?wsdl" atom at the far end makes no difference to the behaviour
 * 
 * tcpdump the connection using:
 * tcpdump -n -nn -s0 -A -i lo 'tcp port 80'
 * Here is the exchange on port 80
 * When tunneling over another server, the local tunneled port (80) and the final destination port (80) 
 * must correspond
 * 
 * --> GET /atsrv-ejb/ws-res-v3/AlarmTILTRestrictedWebService?wsdl  (port 60291 -> 80)
 * <-- Chunked WSDL, many KiB
 * --> POST /atsrv-ejb/ws-res-v3/AlarmTILTRestrictedWebService HTTP/1.1 (port 60292 -> 80)
 * --> <?xml version="1.0" ?><S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"><S:Body><ns2:pingService xmlns:ns2="com.alarmtilt.webservice.soap.res.v3"></ns2:pingService></S:Body></S:Envelope>
 * <-- HTTP/1.1 200 OK, with result...
 * --> Tear down both connections!
 *  
 * 2015.08.11 - First run 
 ******************************************************************************/


public final class Call {

	static final String CLASS = Call.class.name
	static final Logger LOGGER_main = LoggerFactory.getLogger("${CLASS}.main")

	static final String NAMESPACE = 'com.alarmtilt.webservice.soap.res.v3'
	static final String LOCAL_PART = 'ws-res-v3'
	static final QName SERVICE_NAME = new QName(NAMESPACE, LOCAL_PART)

	static final String DEFAULT_CONFIG = '^' + ResourceHelpGroovy.fullyQualifyResourceName(Call.class,'default_config.txt')

	/**
	 * Non-instantiable constructor
	 */

	private Call() {
		cannotHappen("Class cannot be instantiated");
	}

	/**
	 * Generate help text for the command line
	 */

	private static List generateHelpText() {
		// 34567890123456789012345678901234567890123456789012345678901234567890123456789
		List res = []
		res << "--config=CONFIG        : Read configuration from CONFIG. CONFIG can be:"
		res << "                         - Absolute pathname to a file. CONFIG must"
		res << "                           start with '/' or '\\' or a DOS-style drive"
		res << "                           letter (A:\\),"
		res << "                         - Resource on the classpath. CONFIG must start"
		res << "                           with the caret '^',"
		res << "                         - Relative patname of a file (relative to the"
		res << "                           home directory of the current user) in all"
		res << "                           other cases,"
		res << "                         - If not given, uses ${DEFAULT_CONFIG}."
		res << "                         Several 'config' may be given. Later ones"
		res << "                         override earlier ones (useful for having"
		res << "                         credentials in separate files for example)"
		res << "                         If needed, specify encoding of the config file"
		res << "                         by appending '::UTF-8' for example"
		res << "--url=URL              : An URL to the WSDL resource"
		res << "                         You may give two: one for the 'http' scheme,"
		res << "                         one for the 'https' scheme."
		res << "--secure[=Y/N]         : Preferentially select 'https' scheme if"
		res << "                         available. Default is YES."
		res << "--hostnameverify[=Y/N] : Switch SSL hostname verification on/off."
		res << "                         Default is YES."
		res << "--service=SERVICE      : Give name of the remote web service to call."
		res << "--procedure=PROCEDURE  : If the 'service' chosen is 'launch', give the"
		res << "                         name of the AlarmTILT alerting procedure to"
		res << "                         launch."
		res << "--creds=CREDS          : Use credentials string CRED, which must be of"
		res << "                         the form 'USER::PASSWORD'"
		// res << "--verbose[=LEVEL]      : Set verbosity (level is an integer)"
		res << "\n"
		res << "Known SERVICE names are:"
		res << "\n"
		res.addAll(AtwsMap.printOut())
		res << "\n"
		res << "Known PROCEDURE names are:"
		res << "\n"
		res.addAll(AtpMap.printOut())
		return res
	}

	private static List readConfigs(List configNames, List msgs) {
		List res = []
		if (configNames) {
			configNames.each { String what ->
				try {
					boolean lenient = true
					res << new ConfigInfo(what, msgs, lenient)
				}
				catch (Exception exe) {
					msgs << exe.message
				}
			}
		}
		return res
	}

	private static List alignConfigs(Map result, List msgs) {
		List configs = []
		//
		// Next up is "the one constructed from $DEFAULT_CONFIG
		// Then come all the ones indicated on the command line
		//
		List readThese = [DEFAULT_CONFIG]
		if (result[ArgsProcessor.OPTION_CONFIG]) {
			readThese.addAll(result[ArgsProcessor.OPTION_CONFIG])
		}
		configs.addAll(readConfigs(readThese, msgs))
		//
		// Finally comes the one BUILT from the command line
		//
		configs << new
				ConfigInfo(
				result[ArgsProcessor.OPTION_URL],
				result[ArgsProcessor.OPTION_SECURE],
				result[ArgsProcessor.OPTION_HNV],
				result[ArgsProcessor.OPTION_SERVICE],
				result[ArgsProcessor.OPTION_PROCEDURE],
				result[ArgsProcessor.OPTION_CREDS])
		return configs
	}


	public static void main(String[] args) throws java.lang.Exception {
		Logger logger = LOGGER_main
		//
		// Handling of passed arguments:
		// result     = map of key-value pairs, where the "key" is the option string
		// tailValues = list of "Value" instances that could be found at the tail
		//              end of the argument string
		//
		List msgs = []
		Map mm = ArgsProcessor.process(args, msgs)
		Map  result     = mm[ArgsProcessor.tag_result]
		List tailValues = mm[ArgsProcessor.tag_tailValues]
		if (msgs) {
			msgs.each { logger.error("While processing arguments: ${it}") }
		}
		//
		// If help demanded, print and exit
		//
		if (result[ArgsProcessor.OPTION_HELP]) {
			List help = generateHelpText()
			help.each {
				System.err.println(it)
			}
			System.err.flush()
			System.exit(0)
		}
		//
		// Merge all the configs into one!
		//
		List configs = alignConfigs(result, msgs)
		ConfigInfo merged = new ConfigInfo()
		configs.each {
			merged = new ConfigInfo(it, merged)
		}
		logger.info('Resulting merged configuration')
		logger.info("http URL       : ${merged.uriMap['http']}")
		logger.info("https URL      : ${merged.uriMap['https']}")
		logger.info("secure         : ${merged.secure}")
		logger.info("hostnameverify : ${merged.hostnameverify}")
		logger.info("service        : ${merged.service}")
		logger.info("procedure      : ${merged.procedure}")
		logger.info("creds/username : ${merged.credentials?.username}")
		logger.info("creds/password : ....")
		//
		// Ok, "merged" is the thing to use...
		//
		boolean error = false
		if (!merged.hostnameverify) {
			logger.info("Disabling hostname verifier")
			Helper.disableHostnameVerifier()
		}
		URI uri
		if (merged.secure && merged.uriMap['https']) {
			uri = merged.uriMap['https']
		}
		else {
			uri = merged.uriMap['http']
		}
		if (!uri) {
			logger.error("No valid URI! Secure: ${merged.secure}")
			error = true
		}
		if (!merged.service) {
			logger.error('No valid Web Service')
			error = true
		}
		if (error) {
			System.exit(1)
		}
		//
		// Currently the whole WSDL is downloaded.
		// We really don't want that!
		// Consult: http://stackoverflow.com/questions/764772/jax-ws-loading-wsdl-from-jar
		// The URL has to point to the WSDL, but then how to select https ?
		//
		if (AtwsName.makeName('ping') == merged.service) {
			WsResV3 wsService = new WsResV3(uri.toURL(), SERVICE_NAME);
			AlarmTILTRestrictedWebService port = wsService.getAlarmTILTRestrictedWebServicePort();
			logger.info("Invoking service '${merged.service}' to ${uri}");
			try {
				PingServiceResult res = port.pingService();
				if (res.result == PingServiceResultEnum.OK) {
					logger.info(res.result as String)
					logger.info("Looking good - received OK")
					System.exit(0)
				}
				else {
					logger.error(res.result as String)
					logger.error("Something went wrong")
					System.exit(1)
				}
			} catch (Exception exe) {
				logger.error("Service invocation failed", exe)
				System.exit(1)
			}
		}
		else if (AtwsName.makeName('launch') == merged.service) {
			if (!merged.credentials) {
				logger.error('No valid credentials')
				error = true
			}
			if (!merged.procedure) {
				logger.error('No valid procedure')
				error = true
			}
			if (error) {
				System.exit(1)
			}
			WsResV3 wsService = new WsResV3(uri.toURL(), SERVICE_NAME);
			AlarmTILTRestrictedWebService port = wsService.getAlarmTILTRestrictedWebServicePort();
			logger.info("Invoking service '${merged.service}' with procedure '${merged.procedure}' to ${uri}");
			AuthParam auth = new AuthParam()
			/*
			 auth.authDn = merged.credentials.username
			 auth.authPw = merged.credentials.password
			 auth.authType = AuthType.BASIC
			 */

			auth.authDn = "2c3f9e99e369a891c1463ea8bcb65510"
			auth.authType = AuthType.HEX_64

			try {
				LaunchProcedureResult res = port.launchProcedure(auth, new LaunchProcedureParam());
				if (res.result == LaunchProcedureResultEnum.OK) {
					logger.info(res.result as String)
					logger.info("Looking good - received OK")
					System.exit(0)
				}
				else {
					logger.error(res.result as String)
					logger.error("Something went wrong")
					System.exit(1)
				}
			} catch (Exception exe) {
				logger.error("Service invocation failed", exe)
				System.exit(1)
			}
		}
		else {
			logger.error("Unknown web service '${merged.service}'")
			System.exit(1)
		}
	}
}
