package eu.qleap.soapyatc;

import static name.heavycarbon.checks.BasicChecks.*

import java.nio.file.Paths;

import javax.xml.namespace.QName

import name.heavycarbon.utils.AbstractName;
import name.heavycarbon.utils.ResourceHelpGroovy
import name.heavycarbon.utils.Sleep;

import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.slf4j.bridge.SLF4JBridgeHandler

import uk.org.lidalia.sysoutslf4j.context.SysOutOverSLF4J
import v3.res.soap.webservice.alarmtilt.com.AlarmTILTRestrictedWebService
import v3.res.soap.webservice.alarmtilt.com.AuthParam
import v3.res.soap.webservice.alarmtilt.com.AuthType
import v3.res.soap.webservice.alarmtilt.com.LaunchProcedureParam
import v3.res.soap.webservice.alarmtilt.com.LaunchProcedureResult
import v3.res.soap.webservice.alarmtilt.com.LaunchProcedureResultEnum
import v3.res.soap.webservice.alarmtilt.com.PingServiceResult
import v3.res.soap.webservice.alarmtilt.com.PingServiceResultEnum
import v3.res.soap.webservice.alarmtilt.com.ProcedureVariable
import v3.res.soap.webservice.alarmtilt.com.WsResV3
import eu.qleap.soapyatc.argproc.ArgsProcessor
import eu.qleap.soapyatc.argproc.CaseFile
import eu.qleap.soapyatc.config.ConfigInfo
import eu.qleap.soapyatc.config.Credentials
import eu.qleap.soapyatc.elements.AtpMap
import eu.qleap.soapyatc.elements.AtpName
import eu.qleap.soapyatc.elements.AtwsMap
import eu.qleap.soapyatc.elements.AtwsName

/* 34567890123456789012345678901234567890123456789012345678901234567890123456789
 *******************************************************************************
 * Main class to invoke to do a SOAP call to the AlarmTILT server
 * 
 * This has been built from a class generated by Apache CXF
 *
 * Arguments of interest for the runtime:
 * 
 * -Dnetworkaddress.cache.ttl=0 
 * -Dcom.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true 
 * -Dcom.sun.xml.internal.ws.transport.http.HttpAdapter.dump=true
 *
 * It turns out that having the "?wsdl" atom at the far end makes no difference to the behaviour
 * 
 * tcpdump the connection using:
 * 
 * tcpdump -n -nn -s0 -A -i lo 'tcp port 80'
 * 
 * Here is the exchange on port 80
 * 
 * When tunneling over another server, the local tunneled port (80) and the final destination port (80) 
 * must correspond
 * 
 * --> GET /atsrv-ejb/ws-res-v3/AlarmTILTRestrictedWebService?wsdl  (port 60291 -> 80)
 * <-- Chunked WSDL, many KiB
 * --> POST /atsrv-ejb/ws-res-v3/AlarmTILTRestrictedWebService HTTP/1.1 (port 60292 -> 80)
 * --> <?xml version="1.0" ?><S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"><S:Body><ns2:pingService xmlns:ns2="com.alarmtilt.webservice.soap.res.v3"></ns2:pingService></S:Body></S:Envelope>
 * <-- HTTP/1.1 200 OK, with result...
 * --> Tear down both connections!
 *  
 * 2015.08.11 - First run 
 ******************************************************************************/

public final class Call {

	private static final String CLASS = Call.class.name
	private static final Logger LOGGER_main                   = LoggerFactory.getLogger("${CLASS}.main")
	private static final Logger LOGGER_selectWsdlLocationURI  = LoggerFactory.getLogger("${CLASS}.selectWsdlLocationURI")
	private static final Logger LOGGER_ping                   = LoggerFactory.getLogger("${CLASS}.ping")
	private static final Logger LOGGER_launch                 = LoggerFactory.getLogger("${CLASS}.launch")
	private static final Logger LOGGER_realMain               = LoggerFactory.getLogger("${CLASS}.realMain")
	private static final Logger LOGGER_callBasedOnCaseId      = LoggerFactory.getLogger("${CLASS}.callBasedOnCaseId")
	private static final Logger LOGGER_callBasedOnNames       = LoggerFactory.getLogger("${CLASS}.callBasedOnNames")

	enum TagA {
		servicetocall, proceduretolaunch
	}

	/**
	 * Service codes: Some of these are only valid on the command line, some are invokable AlarmTILT services
	 */

	private static final String stc_ping   = AtwsMap.makeName('ping') as String
	private static final String stc_ping10 = AbstractName.namify('ping10')
	private static final String stc_launch = AtwsMap.makeName('launch') as String

	static final String NAMESPACE = 'com.alarmtilt.webservice.soap.res.v3'
	static final QName SERVICE_NAME_HTTP = new QName(NAMESPACE, 'ws-res-v3')
	static final QName SERVICE_NAME_HTTPS = new QName(NAMESPACE, 'ws-res-v3-secured')

	/**
	 * The default config is checked but it doesn't exist on the classpath to avoid confusion 
	 */

	static final String DEFAULT_CONFIG = '^' + ResourceHelpGroovy.fullyQualifyResourceName(Call.class,'default_config.txt')

	/**
	 * Other
	 */

	private static final String DO_THIS = "Configure in config file or on command line. Try '--help' on the command line for hints."

	/**
	 * Non-instantiable constructor
	 */

	private Call() {
		cannotHappen("Do not instantiate ${Call.class.getName()}")
	}

	private static URI selectWsdlLocationURI(ConfigInfo ci) {
		Logger logger = LOGGER_selectWsdlLocationURI
		String error
		URI uri
		if (ci.secure) {
			// if "secure", the https scheme MUST be used; no fallback to http!
			// if there is no entry under 'https', we will throw!
			uri = ci.uriMap['https']
		}
		else {
			// not secure? use http, then
			uri = ci.uriMap['http']
		}
		if (!uri) {
			logger.error("No valid URI configured! Secure was: ${ci.secure}\n${DO_THIS}\n...exiting!")
			error = "No valid URI configured"
		}
		if (error) {
			instaFail("Exiting due to unfixable problem: ${error}")
		}
		return uri
	}

	private static boolean ping(URI uri,AlarmTILTRestrictedWebService port) {
		Logger logger = LOGGER_ping
		checkNotNull(uri)
		checkNotNull(port)
		AtwsName PING = AtwsMap.makeName(stc_ping)
		String rawName = AtwsMap.getRawName(PING)
		logger.info("Invoking service '${rawName}' at ${uri}");
		try {
			PingServiceResult res = port.pingService();
			if (res.result == PingServiceResultEnum.OK) {
				logger.info("Looking good -- received ${res.result}")
				return true
			}
			else {
				logger.error("Something went wrong -- received ${res.result}")
				return false
			}
		} catch (Exception exe) {
			logger.error("Service invocation failed", exe)
			return false
		}
	}

	private static boolean launch(URI uri,AlarmTILTRestrictedWebService port, Credentials creds, AtpName procedureToLaunch) {
		Logger logger = LOGGER_launch
		checkNotNull(uri,"uri")
		checkNotNull(port,"port")
		checkNotNull(creds,"credentials")
		checkNotNull(procedureToLaunch,"procedure to launch")
		AtwsName LAUNCH = AtwsMap.makeName(stc_launch)
		String rawWebServiceName = AtwsMap.getRawName(LAUNCH)
		String rawProcedureName = AtpMap.getRawName(procedureToLaunch)
		logger.info("Invoking service '${rawWebServiceName}' with procedure '${rawProcedureName}' at ${uri}");
		//
		// Filling in credentials
		//
		AuthParam auth = new AuthParam()
		auth.authDn = creds.username
		auth.authPw = creds.password
		auth.authType = AuthType.BASIC
		//
		// There is a procedure called "Alerte WinCC" with a variable called "Defaut" which has to be filled with the
		// "procedure to launch", i.e. "ASA", "Cargolux" etc.
		// Fomerly, there were N "procedures to launch"
		// This is indeed spelled: 'Defaut' (probably from the french: DÃ©faut, which does
		// NOT carry the meaning of "default" though: http://www.cnrtl.fr/lexicographie/d%C3%A9faut)
		//
		LaunchProcedureParam p = new LaunchProcedureParam()
		p.procedureName = "Alerte WinCC"
		ProcedureVariable pv = new ProcedureVariable()
		pv.name = 'Defaut'
		pv.value = rawProcedureName
		// p.getVariables() returns a list that is created on need, so just "get()", then "add()"
		p.getVariables().add(pv)
		try {
			LaunchProcedureResult res = port.launchProcedure(auth, p);
			if (res.result == LaunchProcedureResultEnum.OK) {
				logger.info("Looking good -- received ${res.result}")
				return true
			}
			else {
				logger.error("Something went wrong -- received ${res.result}")
				return false
			}
		} catch (Exception exe) {
			logger.error("Service invocation failed", exe)
			return false
		}
	}

	private static Map callBasedOnCaseId(ConfigInfo ci) {
		Logger logger = LOGGER_callBasedOnCaseId
		List msgs = []
		logger.info("A case id ${ci.caseId} has been given; looking up translation in a case file...")
		String caseFile = ci.casefile
		if (!caseFile) {
			instaFail("Need to have a 'casefile' because the 'case' ${ci.caseId} is indicated, but no file has been given.\n${DO_THIS}")
		}
		// load the "case file"; will throw on problem
		CaseFile cf = new CaseFile(ci.casefile, msgs)
		msgs.each { it -> logger.warn("${it}") }
		//
		// service to call is always LAUNCH
		//
		String serviceToCall = stc_launch
		//
		// procedure to launch is looked up; will throw on problem
		//
		AtpName procedureToLaunch = cf.lookup(ci.caseId)
		logger.info("The case id '${ci.caseId}' maps procedure '${procedureToLaunch}'; proceeding...")
		return [ (TagA.servicetocall) : serviceToCall, (TagA.proceduretolaunch) : procedureToLaunch ]
	}

	private static Map callBasedOnNames(ConfigInfo ci) {
		Logger logger = LOGGER_callBasedOnNames
		String serviceToCall
		AtpName  procedureToLaunch
		//
		// The raw "service" string given on the command line is mapped to an AtwsName, if possible
		//
		AtwsName name = AtwsMap.makeNameWithNullOnFailure(ci.service)
		if (name) {
			serviceToCall = name as String
		}
		else {
			serviceToCall = AbstractName.namifyWithNullOnFailure(ci.service)
		}
		checkNotNull(serviceToCall,"No valid service to call has been given (actual value given was ${ci.service})")

		if (serviceToCall == stc_launch) {
			procedureToLaunch = ci.procedure
			checkNotNull(ci.procedure, "The service-to-call is '${serviceToCall}' but the procedure to launch has not been given.\n${DO_THIS}")
		}
		else {
			if (ci.procedure) {
				logger.warn("The service-to-call is '${serviceToCall}' -- disregarding unneeded procedure '${ci.procedure}'")
			}
		}
		return [ (TagA.servicetocall) : serviceToCall, (TagA.proceduretolaunch) : procedureToLaunch ]
	}

	private static Map whatToCall(ConfigInfo ci) {
		if (ci.caseId != null) {
			return callBasedOnCaseId(ci)
		}
		else {
			return callBasedOnNames(ci)
		}
	}

	private static boolean pingTenTimes(URI uri,AlarmTILTRestrictedWebService port) {
		boolean res = true
		int counter = 10
		boolean first = true
		final int sleep_ms = 1000
		while (res && counter > 0) {
			if (!first) {
				Sleep.sleepFor(sleep_ms)
			}
			else {
				first = false
			}
			res = ping(uri,port)
			counter--
		}
	}

	private static boolean realMain(String[] args) {
		Logger logger = LOGGER_realMain
		//
		// Build a single common "ConfigInfo" by merging those created from config files and the command line
		//
		ConfigInfo ci
		BUILD_CONFIGINFO: {
			def argResult = ArgumentProcessing.makeArgResult(args)
			def configList = ArgumentProcessing.alignConfigsByPriority(argResult)
			ci = ArgumentProcessing.mergeConfigs(configList)
		}
		//
		// In case of tests, we may want to not check the hostname in the X509 certificate
		//
		if (!ci.hostnameverify) {
			logger.warn("ATTENTION: Disabling X509 certificate hostname verifier")
			Helper.disableHostnameVerifier()
		}
		//
		// Now we need to suss out the location of the WSDL file and the actual service to use
		//
		URI wsdlLocationUri
		WsResV3 wsService
		//
		// Case: "wsdlfile" is NOT given
		//
		if (!ci.wsdlfile) {
			//
			// We don't know an on-disk location for the WSDL file. We shall get the WSDL file
			// from the target server instead by letting "wsdlLocationUrl" point to that server.
			// That URL should terminate in an "?wsdl" fragment, though empirically it works
			// without, too.
			//
			// Using this will cause JAX-WS to behave as follows:
			//
			// 1) GET the WSDL from the "wsdlLocationUrl" via HTTP or HTTPS, as specified in the
			//    URL, on a first connection.
			//
			// 2) POST the webservice request to the remote server via HTTP or HTTPS, according
			//    to the scheme used in the "wsdlLocationUrl", on a second connection.
			//
			// This actually works even if there is only a HTTP service endpoint indicated in the
			// WSDL. Interesting.
			//
			// We use what is given as 'urls' from the command line or from the config file and
			// use the 'secure' flag appropriately. This will throw if no good URI could be found.
			//
			wsdlLocationUri = selectWsdlLocationURI(ci)
			//
			// Always use "SERVICE_NAME_HTTP" because that is the only one configured in the
			// AlarmTILT WSDL :-(  ... but this works!
			//
			wsService = new WsResV3(wsdlLocationUri.toURL(), SERVICE_NAME_HTTP)
		}
		else {
			//
			// We do know an on-disk location for the WSDL file. We shall read it from there.
			// JAX-WS expects an URL and we have not installed an URL handler for a scheme like
			// "resource:", so it must be a honest-to-god file for now.
			//
			// Using this will cause JAX-WS to behave as follows:
			//
			// 1) NOT GET the WSDL from the remote server.
			//
			// 2) POST the webservice request to the remote server via HTTP and HTTPS, as selected,
			//    on a first connection.
			//
			// Using HTTP or HTTPS alternatingly demands the that the WSDL properly specify a HTTP
			// and a HTTPS endpoint.
			//
			// Currently, this means manually editing the AlarmTILT WSDL:
			//
			// If the file is missing there will be an exception at connect() time from
			// sun.net.www.protocol.file.FileURLConnection.connect
			//
			wsdlLocationUri = Paths.get(ci.wsdlfile).toUri()
			//
			// The WSDL must list two services, one going via http and one going via https:
			// The WSDL of AlarmTILT only lists the http location, so this must be manually added
			//
			// <wsdl:service name="ws-res-v3">
			//    <wsdl:port binding="tns:ws-res-v3SoapBinding" name="AlarmTILTRestrictedWebServicePort">
			//       <soap:address location="http://v5-webservices.alarmtilt.net/atsrv-ejb/ws-res-v3/AlarmTILTRestrictedWebService"/>
			//    </wsdl:port>
			// </wsdl:service>
			// <wsdl:service name="ws-res-v3-secured">
			//    <wsdl:port binding="tns:ws-res-v3SoapBinding" name="AlarmTILTRestrictedWebServicePort">
			//       <soap:address location="https://v5-webservices.alarmtilt.net/atsrv-ejb/ws-res-v3/AlarmTILTRestrictedWebService"/>
			//    </wsdl:port>
			// </wsdl:service>
			//
			if (ci.secure) {
				wsService = new WsResV3(wsdlLocationUri.toURL(), SERVICE_NAME_HTTPS)
			}
			else {
				wsService = new WsResV3(wsdlLocationUri.toURL(), SERVICE_NAME_HTTP)
			}
		}
		AlarmTILTRestrictedWebService port = wsService.getAlarmTILTRestrictedWebServicePort()
		//
		// Prepare for call; in particular if "case id" is set, invoke a launch of procedure
		//
		String   serviceToCall
		AtpName  procedureToLaunch
		WHAT_TO_CALL: {
			Map wtc           = whatToCall(ci)
			serviceToCall     = wtc[TagA.servicetocall]
			procedureToLaunch = wtc[TagA.proceduretolaunch]
			logger.debug("serviceToCall = ${serviceToCall}, procedureToLaunch = ${procedureToLaunch}")
		}
		//
		// The network stack writes debug info to STDOUT instead of to JUL. Oracle, please!
		// Let's capture it into SLF4J then. We do this here to do it as late as possible.
		//
		SysOutOverSLF4J.sendSystemOutAndErrToSLF4J();
		//
		// Ready to either ping the AlarmTILT server or launch a procedure on it
		//
		boolean res
		switch (serviceToCall) {
			case stc_ping:
				res = ping(wsdlLocationUri,port)
				break
			case stc_ping10:
				res = pingTenTimes(wsdlLocationUri,port)
				break
			case stc_launch:
				res = launch(wsdlLocationUri,port,ci.credentials, procedureToLaunch)
				break
			default:
				logger.error("Unknown (web) service '${serviceToCall}' (originally ${ci.service}) requested -- fix code!")
				res = false
		}
		return res
	}

	public static void main(String[] args) {
		Logger logger = LOGGER_main
		//
		// Redirect Java Util Logging (JUL) into SLF4J, with some overhead.
		// An additional installation to redirect messages writtent to STDOUT
		// into SLF4J will be done once we know the user didn't just request "--help"
		//
		SLF4JBridgeHandler.install();
		//
		// Let's roll.
		// No need to print a timestamp as the logger layout takes care of that
		//
		boolean res
		try {
			logger.info("============== NEW INVOCATION ==============")
			res = realMain(args)
		}
		catch (Exception exe) {
			logger.error("Caught Exception", exe)
			res = false
		}
		finally {
			logger.info("============== TERMINATING with ${res} ==============")
		}
		//
		// Properly exit with 0 = OK and 1 = BAD STUFF HAPPENED
		//
		if (!res) {
			System.exit(1)
		}
		else {
			System.exit(0)
		}
	}
}
